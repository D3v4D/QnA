namespace KnowledgeBaseService.Controllers;

using KnowledgeBaseService.Models;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using KnowledgeBaseService.Services;
using System.Collections.Concurrent;

/// <summary>
/// Controller for handling Question and Answer operations using the knowledge base and LLM
/// </summary>
[ApiController]
[Route("api/[controller]")]
public class QnAController : ControllerBase
{
    private readonly Services.KnowledgeBaseService _knowledgeBaseService;
    private readonly IAnswerService _answerService;
    
    // Thread-safe cache for storing question-answer pairs
    private static readonly ConcurrentDictionary<string, CachedAnswer> _answerCache = new();
    private static readonly TimeSpan _cacheExpiration = TimeSpan.FromHours(24); // Cache for 24 hours

    /// <summary>
    /// Initializes a new instance of the QnAController
    /// </summary>
    /// <param name="knowledgeBaseService">Service for managing and querying the knowledge base</param>
    /// <param name="answerService">Service for generating structured answers using LLM</param>
    public QnAController(Services.KnowledgeBaseService knowledgeBaseService, IAnswerService answerService)
    {
        _knowledgeBaseService = knowledgeBaseService;
        _answerService = answerService;
    }

    /// <summary>
    /// Processes a question and returns a structured answer based on the knowledge base
    /// </summary>
    /// <param name="request">The question request containing the user's question</param>
    /// <returns>A structured answer generated by the LLM based on relevant knowledge base content</returns>
    /// <remarks>
    /// The endpoint:
    /// 1. Checks if the question has been asked before (cache lookup)
    /// 2. If cached and not expired, returns the cached answer
    /// 3. Otherwise, loads the knowledge base if not already loaded
    /// 4. Retrieves the top 3 most relevant chunks from the knowledge base
    /// 5. If relevant content is found, uses Mistral AI to generate a structured answer
    /// 6. If no relevant content is found, returns a failure message without calling the LLM
    /// 7. Falls back to raw contexts if the LLM call fails
    /// 8. Caches the answer for future requests
    /// </remarks>
    /// <response code="200">Returns the structured answer</response>
    /// <response code="400">If the request is invalid</response>
    [HttpPost("ask", Name = "AskQuestion")]
    [ProducesResponseType(typeof(QnAResponse), StatusCodes.Status200OK, "application/json")]
    [ProducesResponseType(StatusCodes.Status400BadRequest)]
    public async Task<QnAResponse> AskQuestion([FromBody] QnaRequest request)
    {
        // Normalize the question for cache lookup (lowercase, trim whitespace)
        var normalizedQuestion = request.Question.Trim().ToLowerInvariant();
        
        // Check if answer is in cache
        if (_answerCache.TryGetValue(normalizedQuestion, out var cachedAnswer))
        {
            // Check if cache entry is still valid
            if (DateTime.UtcNow - cachedAnswer.Timestamp < _cacheExpiration)
            {
                Console.WriteLine($"Cache hit for question: '{request.Question}'");
                return new QnAResponse()
                {
                    Answer = cachedAnswer.Answer
                };
            }
            else
            {
                // Remove expired cache entry
                _answerCache.TryRemove(normalizedQuestion, out _);
                Console.WriteLine($"Cache expired for question: '{request.Question}'");
            }
        }
        
        Console.WriteLine($"Cache miss for question: '{request.Question}' - generating new answer");
        
        // Load knowledge base if not already loaded
        if (_knowledgeBaseService.GetChunkCount() == 0)
        {
            _knowledgeBaseService.LoadKnowledgeBase();
        }
        
        // Get relevant contexts from knowledge base
        var relevantContexts = _knowledgeBaseService.GetAnswers(request.Question, topK: 3);
        
        // If no relevant contexts found, return a failure message without calling Mistral
        if (relevantContexts == null || relevantContexts.Count == 0)
        {
            Console.WriteLine($"Failed question: No relevant context found for '{request.Question}'");
            var noContextAnswer = "I couldn't find any relevant information in the knowledge base to answer your question.";
            
            // Cache the "no context" response
            CacheAnswer(normalizedQuestion, noContextAnswer);
            
            return new QnAResponse()
            {
                Answer = noContextAnswer
            };
        }
        
        // Generate structured answer using Mistral API
        try
        {
            var structuredAnswer = await _answerService.GenerateAnswerAsync(request.Question, relevantContexts);
            
            // Cache the successful answer
            CacheAnswer(normalizedQuestion, structuredAnswer);
            
            return new QnAResponse()
            {
                Answer = structuredAnswer
            };
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error generating answer with Mistral: {ex.Message}");
            
            // Fallback to returning the raw contexts if Mistral fails
            var fallbackAnswer = "I found relevant information but couldn't generate a structured answer:\n\n" +
                                string.Join("\n\n---\n\n", relevantContexts);
            
            // Cache the fallback answer
            CacheAnswer(normalizedQuestion, fallbackAnswer);
            
            return new QnAResponse()
            {
                Answer = fallbackAnswer
            };
        }
    }
    
    /// <summary>
    /// Stores an answer in the cache
    /// </summary>
    /// <param name="normalizedQuestion">The normalized question as cache key</param>
    /// <param name="answer">The answer to cache</param>
    private void CacheAnswer(string normalizedQuestion, string answer)
    {
        _answerCache[normalizedQuestion] = new CachedAnswer
        {
            Answer = answer,
            Timestamp = DateTime.UtcNow
        };
        Console.WriteLine($"Cached answer for question. Total cached: {_answerCache.Count}");
    }
    
    /// <summary>
    /// Internal method to clear the cache (called automatically after knowledge base updates)
    /// </summary>
    public static void ClearCacheInternal()
    {
        var count = _answerCache.Count;
        _answerCache.Clear();
        Console.WriteLine($"Cache cleared. Removed {count} entries.");
    }
    
    /// <summary>
    /// Represents a cached answer with timestamp
    /// </summary>
    private sealed class CachedAnswer
    {
        public string Answer { get; set; } = string.Empty;
        public DateTime Timestamp { get; set; }
    }
}